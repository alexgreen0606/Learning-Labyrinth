package com.learninglabyrinth.backend.services;

import java.util.*;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.learninglabyrinth.backend.models.MazeAttempt;
import com.learninglabyrinth.backend.models.MazeLayout;
import com.learninglabyrinth.backend.repositories.MazeAttemptRepository;
import com.learninglabyrinth.backend.robot.MovementEnum;
import com.learninglabyrinth.backend.runner.UserCodeProcess;

@Service
public class MazeAttemptService {
  public MazeAttemptRepository mazeAttemptRepository;
  @Autowired
  AccountService accountService;
  @Autowired
  MazeService mazeService;

  public MazeAttemptService(MazeAttemptRepository mazeAttemptRepository) {
    this.mazeAttemptRepository = mazeAttemptRepository;
  }

  public List<MazeAttempt> getMazeAttempts() {
    return mazeAttemptRepository.findAll();
  }

  public MazeAttempt findMostRecent(long mazeId, long accountId) {
    MazeAttempt recent = mazeAttemptRepository.findFirstByMazeIdAndAccountIdOrderByDateDesc(mazeId, accountId)
        .orElseThrow();
    return recent;
  }

  public MazeAttempt findBest(long mazeId, long accountId) {
    try {
      MazeAttempt best = mazeAttemptRepository
          .findFirstByMazeIdAndAccountIdAndIsSuccessOrderByNumMovesAsc(mazeId, accountId, true).orElseThrow();
      return best;
    } catch (Exception e) {
      return findMostRecent(mazeId, accountId);
    }
  }

  /**
   * With the given MazeAttempt information, process the Java Text and record
   * the result back to the input MazeAttempt object.
   * 
   * @param token the token corresponding to the user
   */
  public MazeAttempt createMazeAttempt(UUID token,
      Long mazeId,
      String userCode,
      boolean isActualRun) {
    List<MovementEnum> movements;
    MazeLayout mazeLayout;
    Long accountId;
    MazeAttempt attempt;
    String listReturn;
    MovementEnum lastMove;
    // initialize variables necessary to conduct attempt
    accountId = AccountService.hashMap.get(token).id;
    attempt = new MazeAttempt(mazeId, accountId, userCode);
    mazeLayout = mazeService.getMazeLayout(mazeId).orElseThrow();
    // start process, parse return
    UserCodeProcess userCodeProcess = new UserCodeProcess();
    listReturn = userCodeProcess.startProcess(userCode, mazeLayout.layout);

    movements = parseEnumList(listReturn);
    // check last enumerator, set attempt result
    lastMove = movements.get(movements.size() - 1);
    attempt.setIsSuccess(lastMove == MovementEnum.SUCCESS);
    // user made no moves or did not finish, append to get correct move count
    if (lastMove != MovementEnum.SUCCESS && lastMove != MovementEnum.FAILURE) {
      movements.add(MovementEnum.FAILURE);
    }
    attempt.setMovements(movements);
    attempt.setNumMoves(movements.size() - 1);
    // save maze attempt to repository if an actual run, do not save if test run
    if (isActualRun) {
      manageMazePopularity(accountId, mazeLayout); // check for maze use update
      return mazeAttemptRepository.save(attempt);
    } else {
      return attempt;
    }
  }

  /**
   * Parses the string representation of the MovementEnum list generated by the
   * attempt.
   * 
   * @param input: The string returned by the attempt process
   * @return enumList: The list of MovementEnums restored to its original format
   */
  private static List<MovementEnum> parseEnumList(String input) {
    // remove square brackets
    String withoutBrackets;
    if (input.length() < 3) { // if no moves made, input will have length < 3
      withoutBrackets = "FAILURE";
    } else {
      withoutBrackets = input.substring(input.indexOf('[') + 1,
          input.indexOf(']'));
    }
    // split using comma
    String[] enumValues = withoutBrackets.split(",");
    // trim and convert to enumerator
    List<MovementEnum> enumList = new ArrayList<>();
    for (String value : enumValues) {
      MovementEnum enumConstant = MovementEnum.valueOf(value.trim());
      enumList.add(enumConstant);
    }
    return enumList;
  }

  /**
   * Checks to see if there are no attempts with both the specified accountId
   * and mazeId in the repository. If no such record exists, the maze has been
   * attempted by a new user, and it's uses field is incremented.
   * 
   * @param accountId:  The account id of the user that made the attempt
   * @param mazeLayout: The maze id of the maze that was attempted
   */
  private void manageMazePopularity(Long accountId, MazeLayout mazeLayout) {
    if (!mazeAttemptRepository.existsByAccountIdAndMazeId(accountId,
        mazeLayout.id)) {
      mazeLayout.uses++;
      mazeService.saveMazeLayout(mazeLayout);
    }
  }
}
